#include <string.h>
#include <stdint.h>
#include <map>
#include <string>
#include <fstream>
#include <boost/assign.hpp>
#include "keyvalues.h"
#include "decompiler.h"
#include "vtex.h"

#include <iostream>

using std::ios;

std::map<std::string, std::string> szTexParamAliases =
boost::assign::map_list_of
	("g_tColor",              "TextureColor")
	("g_tColor0",             "TextureColor0")
	("g_tSpecular0",          "TextureReflectance0")
	("g_tSpecular1",          "TextureReflectance1")
	("g_tSpecular2",          "TextureReflectance2")
	("g_tSpecular3",          "TextureReflectance3")
	("g_tDetail",             "TextureDetail")
	("g_tDetail2",            "TextureDetail2")
	("g_tSpecularWarp",       "TextureSpecularWarp")
	("g_tDiffuseWarp",        "TextureDiffuseWarp")
	("g_tFresnelColorWarp3D", "TextureFresnelColorWarp3D")
	("g_tCubeMap",            "TextureCubeMap")
	("g_tEnvironmentMap",     "TextureEnvironmentMap");

void S2Decompiler::DecompileVMAT(const std::string& szFilename, const std::string& szOutputDirectory)
{
	char szBuffer[4];
	char * szMaterialName = NULL;
	char * szShaderName = NULL;

	int32_t i, j;
	uint32_t nNumBlocks;

	KeyValues sRERLInfo, sNTROInfo;
	KeyValues sIntParams, sFloatParams, sVectorParams, sTextureParams;
	KeyValues sIntAttribs, sFloatAttribs, sVectorAttribs, sTextureAttribs, sStringAttribs;

	std::fstream f;
	std::streamoff p1;
	f.open(szFilename, ios::in | ios::binary);
	if (!f.is_open())
		throw std::string("Could not open file \"" + szFilename + "\" for reading.");

	f.seekg(12);
	f.read((char *)&nNumBlocks, 4);
	for (nNumBlocks; nNumBlocks > 0; nNumBlocks--)
	{
		f.read(szBuffer, 4);
		if (strncmp(szBuffer, "RERL", 4) == 0)
		{
			ProcessRERLBlock(f, sRERLInfo);
		}
		else if (strncmp(szBuffer, "NTRO", 4) == 0)
		{
			ProcessNTROBlock(f, sNTROInfo);
		}
		//TODO: Use the NTRO info for the data because I'm stupid and forgot to
		else if (strncmp(szBuffer, "DATA", 4) == 0)
		{
			f.read(szBuffer, 4);
			p1 = f.tellg();
			f.seekg(*(int*)szBuffer - 4, ios::cur);

			ReadOffsetString(f, szMaterialName);
			ReadOffsetString(f, szShaderName);

			ReadKVBlock(f, sIntParams, 4, 4);
			ReadKVBlock(f, sFloatParams, 4, 4);
			ReadKVBlock(f, sVectorParams, 4, 16);
			ReadKVBlock(f, sTextureParams, 8, 8);
			f.seekg(8, ios::cur);		// Skip dynamic params and dynamic texture params since we don't know how to decompile them yet
			f.seekg(8, ios::cur);       // (It's some kind of compiled script or something, idk)
			ReadKVBlock(f, sIntAttribs, 4, 4);
			ReadKVBlock(f, sFloatAttribs, 4, 4);
			ReadKVBlock(f, sVectorAttribs, 4, 16);	//Unconfirmed
			ReadKVBlock(f, sTextureAttribs, 8, 8);	//Unconfirmed
			ReadKVBlock(f, sStringAttribs, 4, 0);

			f.seekg(p1 + 4);
		}
		else if (strncmp(szBuffer, "REDI", 4) == 0)
		{
			f.seekg(8, ios::cur);
		}
		else
		{
			throw std::string("Encountered invalid block type.");
		}
	}
	f.close();

	std::string szOutputName = szFilename.substr(szFilename.find_last_of("\\/") + 1);
	szOutputName = szOutputName.substr(0, szOutputName.find_last_of(".")) + ".vmat";

	f.open(szOutputDirectory + "\\" + szOutputName, ios::out);
	if (!f.is_open())
		throw std::string("Could not open file \"" + szOutputDirectory + "\\" + szOutputName + "\" for writing.");

	f << "// This file has been auto-generated by Source 2 Decompiler\n\nLayer0\n{\n";
	f << "\tshader \"" << szShaderName << "\"\n\n";
	for (i = 0; i < sIntParams.size; i++)
		f << "\t" << sIntParams.name[i] << " " << *(int*)sIntParams.data[i] << "\n";
	for (i = 0; i < sIntAttribs.size; i++)
		f << "\t" << sIntAttribs.name[i] << " " << *(int*)sIntAttribs.data[i] << "\n";
	f << "\n";
	f.precision(6);
	for (i = 0; i < sFloatParams.size; i++)
		f << "\t" << sFloatParams.name[i] << " \"" << *(float*)sFloatParams.data[i] << "\"\n";
	for (i = 0; i < sFloatAttribs.size; i++)
		f << "\t" << sFloatAttribs.name[i] << " \"" << *(float*)sFloatAttribs.data[i] << "\"\n";
	f << "\n";
	for (i = 0; i < sVectorParams.size; i++)
	{
		if (strncmp(sVectorParams.name[i], "g_vTexCoordScale", 16) == 0)
			f << "\t" << std::fixed << sVectorParams.name[i] << " \"[" << *(float*)&sVectorParams.data[i][0] << " " << *(float*)&sVectorParams.data[i][4] << "]\"\n\tg_vTexCoordOffset \"[" << *(float*)&sVectorParams.data[i][8] << " " << *(float*)&sVectorParams.data[i][12] << "]\"\n";
		else if (strncmp(sVectorParams.name[i], "g_vDetailTexCoordScale", 22) == 0)
			f << "\t" << std::fixed << sVectorParams.name[i] << " \"[" << *(float*)&sVectorParams.data[i][0] << " " << *(float*)&sVectorParams.data[i][4] << "]\"\n\tg_vDetailTexCoordOffset \"[" << *(float*)&sVectorParams.data[i][8] << " " << *(float*)&sVectorParams.data[i][12] << "]\"\n";
		else
			f << "\t" << std::fixed << sVectorParams.name[i] << " \"[" << *(float*)&sVectorParams.data[i][0] << " " << *(float*)&sVectorParams.data[i][4] << " " << *(float*)&sVectorParams.data[i][8] << " " << *(float*)&sVectorParams.data[i][12] << "]\"\n";
	}
	for (i = 0; i < sVectorAttribs.size; i++)
		f << "\t" << std::fixed << sVectorAttribs.name[i] << " \"[" << *(float*)&sVectorAttribs.data[i][0] << " " << *(float*)&sVectorAttribs.data[i][4] << " " << *(float*)&sVectorAttribs.data[i][8] << " " << *(float*)&sVectorAttribs.data[i][12] << "]\"\n";
	f << "\n";

	for (i = 0; i < sTextureParams.size; i++)
	{
		bool bIsDefaultResource = false;
		std::string szResourceName;
		for (j = 0; j < sRERLInfo.size; j++)
		{
			if (strncmp(sTextureParams.data[i], sRERLInfo.data[j], 8) == 0)
			{
				szResourceName = std::string(sRERLInfo.name[j]);
				break;
			}
		}

		//Skip default resources; these will be added automatically by the Material Editor anyways
		if ((szResourceName.empty()) || (strncmp(szResourceName.c_str(), "materials/default/", 18) == 0))
			continue;

		DecompileVTEX(_szBaseDirectory + "\\" + szResourceName + "_c", szOutputDirectory, false, false);

		std::string szFileExt = szResourceName.substr(szResourceName.length() - 18, 5);
		std::string szImageName = szResourceName;
		std::string szTexParamName = std::string(sTextureParams.name[i]);

		if ((szFileExt == "_tga_") || (szFileExt == "_psd_"))
			szImageName = szImageName.substr(0, szImageName.length() - 18);
		if (szResourceName.substr(szResourceName.length() - 23, 5) == "_z000")
		szImageName = szImageName.substr(0, szImageName.length() - 5);

		szImageName = szImageName.substr(szImageName.find_last_of("\\/") + 1);
		szImageName = szImageName.substr(0, szImageName.find_last_of(".")) + ".tga";
		if ((szTexParamName == "g_tColor1") || (szTexParamName == "g_tColor2") || (szTexParamName == "g_tColor3"))
		{
			std::string szImageName2 = szImageName.substr(0, szImageName.find_last_of(".")) + "_a.tga";
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName2, IMAGE_CHANNEL_ALPHA);
			f << "\tTextureColor" << szTexParamName[8] << " \"" << szImageName << "\"\n";
			f << "\tTextureRevealMask" << szTexParamName[8] << " \"" << szImageName2 << "\"\n";
		}
		else if (szTexParamName == "g_tColorTranslucency")
		{
			std::string szImageName2 = szImageName.substr(0, szImageName.find_last_of(".")) + "_a.tga";
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName2, IMAGE_CHANNEL_ALPHA);
			f << "\tTextureColor \"" << szImageName << "\"\n";
			f << "\tTextureTranslucency \"" << szImageName2 << "\"\n";
		}
		else if (szTexParamName == "g_tNormal")
		{
			FillImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName, IMAGE_CHANNEL_RED, 128);
			FillImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName, IMAGE_CHANNEL_BLUE, 255);
			f << "\tTextureNormal \"" << szImageName << "\"\n";
		}
		//Unconfirmed about the specular part
		else if (szTexParamName == "g_tNormalSpecularMask")
		{
			std::string szImageName2 = szImageName.substr(0, szImageName.find_last_of(".")) + "_a.tga";
			
			SwapImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName, IMAGE_CHANNEL_ALPHA, IMAGE_CHANNEL_RED);
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName2, IMAGE_CHANNEL_ALPHA);
			
			f << "\tTextureNormal \"" << szImageName << "\"\n";
			f << "\tTextureSpecularMask \"" << szImageName2 << "\"\n";
		}
		else if (szTexParamName == "g_tMasks1")
		{
			std::string szImageName2 = szImageName.substr(0, szImageName.find_last_of(".")) + "_a.tga";
			std::string szImageName3 = szImageName.substr(0, szImageName.find_last_of(".")) + "_r.tga";
			std::string szImageName4 = szImageName.substr(0, szImageName.find_last_of(".")) + "_g.tga";
			std::string szImageName5 = szImageName.substr(0, szImageName.find_last_of(".")) + "_b.tga";

			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName2, IMAGE_CHANNEL_ALPHA);
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName3, IMAGE_CHANNEL_RED);
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName4, IMAGE_CHANNEL_GREEN);
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName5, IMAGE_CHANNEL_BLUE);

			f << "\tTextureSelfIllumMask \"" << szImageName2 << "\"\n";
			f << "\tTextureDetailMask \"" << szImageName3 << "\"\n";
			f << "\tTextureDiffuseWarpMask \"" << szImageName4 << "\"\n";
			f << "\tTextureMetalnessMask \"" << szImageName5 << "\"\n";
		}
		else if (szTexParamName == "g_tMasks2")
		{
			std::string szImageName2 = szImageName.substr(0, szImageName.find_last_of(".")) + "_a.tga";
			std::string szImageName3 = szImageName.substr(0, szImageName.find_last_of(".")) + "_r.tga";
			std::string szImageName4 = szImageName.substr(0, szImageName.find_last_of(".")) + "_g.tga";
			std::string szImageName5 = szImageName.substr(0, szImageName.find_last_of(".")) + "_b.tga";

			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName2, IMAGE_CHANNEL_ALPHA);
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName3, IMAGE_CHANNEL_RED);
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName4, IMAGE_CHANNEL_GREEN);
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName5, IMAGE_CHANNEL_BLUE);

			f << "\tTextureSpecularExponent \"" << szImageName2 << "\"\n";
			f << "\tTextureSpecularMask \"" << szImageName3 << "\"\n";
			f << "\tTextureRimMask \"" << szImageName4 << "\"\n";
			f << "\tTextureTintByBaseMask \"" << szImageName5 << "\"\n";
		}
		else if (szTexParamName == "g_tColorWarp3D")
		{
			std::string szImageName2;
			for (uint8_t j = 0; j < 4; j++)
			{
				std::string szNewImageName = szImageName.substr(0, szImageName.find_last_of("."));
				szNewImageName += "_z" + std::to_string((j / 100) % 10) + std::to_string((j / 10) % 10) + std::to_string(j % 10) + ".tga";
				if (j == 0)
					szImageName2 = szNewImageName;
				SwapImageChannel(szOutputDirectory + "\\" + szNewImageName, szOutputDirectory + "\\" + szNewImageName, IMAGE_CHANNEL_RED, IMAGE_CHANNEL_BLUE);
			}
			if (szImageName2.empty())
				throw std::string("Invalid color warp 3D image.");
			f << "\tTextureColorWarp3D \"" << szImageName2 << "\"\n";
		}
		else if (szTexParamName == "g_tFresnelWarp")
		{
			std::string szImageName2 = szImageName.substr(0, szImageName.find_last_of(".")) + "_r.tga";
			std::string szImageName3 = szImageName.substr(0, szImageName.find_last_of(".")) + "_g.tga";
			std::string szImageName4 = szImageName.substr(0, szImageName.find_last_of(".")) + "_b.tga";

			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName2, IMAGE_CHANNEL_RED);
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName3, IMAGE_CHANNEL_GREEN);
			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName4, IMAGE_CHANNEL_BLUE);

			f << "\tTextureFresnelWarpRim \"" << szImageName2 << "\"\n";
			f << "\tTextureFresnelWarpColor \"" << szImageName3 << "\"\n";
			f << "\tTextureFresnelWarpSpec \"" << szImageName4 << "\"\n";
		}
		else if (szTexParamName == "g_tScrollSpeed")
		{
			std::string szImageName2 = szImageName.substr(0, szImageName.find_last_of(".")) + "_a.tga";
			std::string szImageName3 = szImageName.substr(0, szImageName.find_last_of(".")) + "_g.tga";

			ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName3, IMAGE_CHANNEL_GREEN);
			
			for (j = 0; j < sIntParams.size; j++)
			{
				if (strncmp(sIntParams.name[j], "F_TRANSLUCENT", 13) == 0)
				{
					ExtractImageChannel(szOutputDirectory + "\\" + szImageName, szOutputDirectory + "\\" + szImageName2, IMAGE_CHANNEL_ALPHA);
					f << "\tTextureTranslucency \"" << szImageName2 << "\"\n";
					break;
				}
			}
			f << "\tTextureScrollSpeed \"" << szImageName3 << "\"\n";
		}
		else if (szTexParamAliases.count(szTexParamName))
		{
			std::string szTexParamAlias = szTexParamAliases[szTexParamName];
			f << "\t" << szTexParamAlias << " \"" << szImageName << "\"\n";
		}
		else
		{
			std::cout << "\t" << szTexParamName << " " << szFilename << std::endl;
		}
	}
	f << "}";

	f.close();

	if (szMaterialName != NULL)
		delete[] szMaterialName;

	if (szShaderName != NULL)
		delete[] szShaderName;

}