#include "string.h"
#include <stdint.h>
#include <map>
#include <string>
#include <fstream>
#include "decompiler.h"
#include "keyvalues.h"

#include <iostream>

using std::ios;

bool WriteGenericVPCFData(std::fstream& f, KeyValues& kv, uint32_t uIndex)
{
	uint16_t uDataType = *(uint16_t*)(&kv.name[uIndex][strlen(kv.name[uIndex]) + 1]);
	if (uDataType == NTRO_DATA_TYPE_ENUM)
		f << "symbol " << kv.name[uIndex] << " = " << *(uint32_t*)kv.data[uIndex] << "\n";
	else if ((uDataType == NTRO_DATA_TYPE_HANDLE) || (uDataType == NTRO_DATA_TYPE_STRING) || (uDataType == NTRO_DATA_TYPE_NAME))
		f << "string " << kv.name[uIndex] << " = \"" << ((kv.data[uIndex] == NULL) ? "" : kv.data[uIndex]) << "\"\n";
	else if (uDataType == NTRO_DATA_TYPE_INTEGER)
		f << "int " << kv.name[uIndex] << " = " << *(int32_t*)kv.data[uIndex] << "\n";
	else if (uDataType == NTRO_DATA_TYPE_FLOAT)
		f << "float " << kv.name[uIndex] << " = " << std::fixed << *(float*)kv.data[uIndex] << "\n";
	else if (uDataType == NTRO_DATA_TYPE_VECTOR3)
		f << "float(3) " << kv.name[uIndex] << " = ( " << std::fixed << *(float*)&kv.data[uIndex][0] << ", " << *(float*)&kv.data[uIndex][4] << ", " << *(float*)&kv.data[uIndex][8] << " )\n";
	else if (uDataType == NTRO_DATA_TYPE_VECTOR4)
		f << "int(4) " << kv.name[uIndex] << " = ( " << std::fixed << (uint32_t)*(uint8_t*)&kv.data[uIndex][0] << ", " << (uint32_t)*(uint8_t*)&kv.data[uIndex][1] << ", " << (uint32_t)*(uint8_t*)&kv.data[uIndex][2] << ", " << (uint32_t)*(uint8_t*)&kv.data[uIndex][3] << " )\n";
	else if (uDataType == NTRO_DATA_TYPE_BOOLEAN)
		f << "bool " << kv.name[uIndex] << " = " << (*(bool*)kv.data[uIndex] ? "true" : "false") << "\n";
	else
		return false;
	return true;
}

void S2Decompiler::DecompileVPCF(const std::string& szFilename, const std::string& szOutputDirectory)
{
	char szBuffer[4];

	uint32_t nNumBlocks;

	KeyValues sRERLInfo, sNTROInfo;
	KeyValues sVPCFInfo;

	std::fstream f;
	std::streamoff p;
	f.open(szFilename, ios::in | ios::binary);
	if (!f.is_open())
		throw std::string("Could not open file \"" + szFilename + "\" for reading.");

	f.seekg(12);
	f.read((char *)&nNumBlocks, 4);
	for (nNumBlocks; nNumBlocks > 0; nNumBlocks--)
	{
		f.read(szBuffer, 4);
		if (strncmp(szBuffer, "RERL", 4) == 0)
		{
			ProcessRERLBlock(f, sRERLInfo);
		}
		else if (strncmp(szBuffer, "DATA", 4) == 0)
		{
			f.read(szBuffer, 4);
			p = f.tellg();
			f.seekg(*(int*)szBuffer - 4, ios::cur);

			ReadStructuredData(f, sVPCFInfo);

			f.seekg(p + 4);
		}
		else if (strncmp(szBuffer, "NTRO", 4) == 0)
		{
			ProcessNTROBlock(f, sNTROInfo);
		}
		else if (strncmp(szBuffer, "REDI", 4) == 0)
		{
			f.seekg(8, ios::cur);
		}
		else
		{
			throw std::string("Encountered invalid block type.");
		}
	}
	f.close();

	std::string szOutputName = szFilename.substr(szFilename.find_last_of("\\/") + 1);
	szOutputName = szOutputName.substr(0, szOutputName.find_last_of(".")) + ".vpcf";

	f.open(szOutputDirectory + "\\" + szOutputName, ios::out);
	if (!f.is_open())
		throw std::string("Could not open file \"" + szOutputDirectory + "\\" + szOutputName + "\" for writing.");

	f.precision(6);
	f << "// This file has been auto-generated by Source 2 Decompiler\n";
	f << "// https://github.com/Dingf/Source-2-Decompiler\n";
	f << "<!-- schema text{7e125a45-3d83-4043-b292-9e24f8ef27b4} generic {198980d8-3a93-4919-b4c6-dd1fb07a3a4b} -->\n\n";
	f << "CParticleSystemDefinition CParticleSystemDefinition_0\n{\n";
	for (int32_t i = 0; i < sVPCFInfo.size; i++)
	{
		uint16_t uDataType = *(uint16_t*)(&sVPCFInfo.name[i][strlen(sVPCFInfo.name[i]) + 1]);

		f << "\t";
		if ((!WriteGenericVPCFData(f, sVPCFInfo, i)) && (uDataType == NTRO_DATA_TYPE_STRUCT))
		{
			f.seekp(-1, ios::cur);
			if (strncmp(sVPCFInfo.name[i], "m_Children\0", 11) == 0)
			{
				KeyValues* sChildren = (KeyValues*)sVPCFInfo.data[i];
				f << "\tParticleChildrenInfo_t[] m_Children =\n\t[\n";
				for (int32_t j = 0; j < sChildren->size; j++)
				{
					f << "\t\t" << sChildren->name[j] << "\n\t\t{\n";
					KeyValues* sChild = (KeyValues*)sChildren->data[j];
					for (int32_t k = 0; k < sChild->size; k++)
					{
						f << "\t\t\t";
						WriteGenericVPCFData(f, *sChild, k);
					}
					f << "\t\t}" << ((j == sChildren->size - 1) ? "\n" : ",\n");
				}
				f << "\t]\n";
			}
			else
			{
				KeyValues* sOperators = (KeyValues*)sVPCFInfo.data[i];
				f << "\tCParticleOperator*[] " << sVPCFInfo.name[i] << " =\n\t[\n";
				for (int32_t j = 0; j < sOperators->size; j++)
					f << "\t\t&" << sOperators->name[j] << "_" << j << ((j < sOperators->size - 1) ? ",\n" : "\n");
				f << "\t]\n";
			}
		}
	}
	f << "}\n";


	for (int32_t i = 0; i < sVPCFInfo.size; i++)
	{
		uint16_t uDataType = *(uint16_t*)(&sVPCFInfo.name[i][strlen(sVPCFInfo.name[i]) + 1]);
		if ((uDataType == NTRO_DATA_TYPE_STRUCT) && (strncmp(sVPCFInfo.name[i], "m_Children\0", 11) != 0))
		{
			KeyValues* sOperators = (KeyValues*)sVPCFInfo.data[i];
			for (int32_t j = 0; j < sOperators->size; j++)
			{
				f << "\n" << sOperators->name[j] << " " << sOperators->name[j] << "_" << j << "\n{\n";
				KeyValues* sOperator = (KeyValues*)sOperators->data[j];
				for (int32_t k = 0; k < sOperator->size; k++)
				{
					f << "\t";
					WriteGenericVPCFData(f, *sOperator, k);
				}
				f << "}\n";
			}
		}
	}
	f.close();

}